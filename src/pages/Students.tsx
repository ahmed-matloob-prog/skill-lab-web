import React, { useState, useEffect } from 'react';
import {
  Box,
  Typography,
  Button,
  Dialog,
  DialogTitle,
  DialogContent,
  DialogActions,
  TextField,
  Grid,
  Card,
  CardContent,
  IconButton,
  Chip,
  Alert,
  CircularProgress,
  ToggleButton,
  ToggleButtonGroup,
  FormControl,
  InputLabel,
  Select,
  MenuItem,
  Table,
  TableBody,
  TableCell,
  TableContainer,
  TableHead,
  TableRow,
  Paper,
} from '@mui/material';
import {
  Add,
  Edit,
  Delete,
  Upload,
  Download,
} from '@mui/icons-material';
import { DataGrid, GridColDef, GridActionsCellItem } from '@mui/x-data-grid';
import { useDatabase } from '../contexts/DatabaseContext';
import { useAuth } from '../contexts/AuthContext';
import { logger } from '../utils/logger';
import { Student, Group } from '../types';
import {
  importStudentsFromExcel,
  downloadStudentTemplate,
  importStudentsByGroupsFromExcel,
  generateStudentGroupImportTemplate
} from '../utils/excelUtils';
import DatabaseService from '../services/databaseService';
import { sanitizeString, validateName } from '../utils/validator';

const Students: React.FC = () => {
  const { students, groups, addStudent, addStudents, updateStudent, deleteStudent, refreshStudents, forceRefresh, loading } = useDatabase();
  const { user } = useAuth();
  
  const [openDialog, setOpenDialog] = useState(false);
  const [editingStudent, setEditingStudent] = useState<Student | null>(null);
  const [selectedYear, setSelectedYear] = useState<number | 'all'>('all');
  const [selectedGroup, setSelectedGroup] = useState<string>('all');
  const [selectedStudent, setSelectedStudent] = useState<Student | null>(null);
  
  // Form state - Simplified to essential fields only
  const [formData, setFormData] = useState({
    name: '',
    year: 1,
    groupId: '',
  });

  const [error, setError] = useState<string | null>(null);
  const [importDialogOpen, setImportDialogOpen] = useState(false);
  const [importResults, setImportResults] = useState<{
    success: number;
    errors: string[];
    timestamp?: number;
  } | null>(null);
  const [refreshTrigger, setRefreshTrigger] = useState(0);
  const [loadingImport, setLoadingImport] = useState(false);
  const [validationErrors, setValidationErrors] = useState<{ [key: string]: string }>({});

  // Group import state
  const [groupImportDialogOpen, setGroupImportDialogOpen] = useState(false);
  const [groupImportPreview, setGroupImportPreview] = useState<Array<{
    name: string;
    groupId: string;
    year: number;
    status: 'new' | 'exists' | 'error';
    message?: string;
    autoGeneratedId?: string;
  }>>([]);
  const [groupImportWarnings, setGroupImportWarnings] = useState<string[]>([]);
  const [groupImportErrors, setGroupImportErrors] = useState<string[]>([]);
  const [loadingGroupImport, setLoadingGroupImport] = useState(false);

  // Force refresh when trigger changes
  useEffect(() => {
    if (refreshTrigger > 0) {
      refreshStudents();
    }
  }, [refreshTrigger]);

  // Filter students based on user permissions and selected filters
  const filteredStudents = students.filter(student => {
    // For trainers, only show students from their assigned groups AND assigned years
    if (user?.role === 'trainer') {
      if (user?.assignedGroups && !user.assignedGroups.includes(student.groupId)) {
        return false;
      }
      if (user?.assignedYears && !user.assignedYears.includes(student.year)) {
        return false;
      }
    }
    // Handle year filter with type coercion
    if (selectedYear !== 'all') {
      const studentYear = typeof student.year === 'string' ? Number(student.year) : student.year;
      const filterYear = typeof selectedYear === 'string' ? Number(selectedYear) : selectedYear;
      if (studentYear !== filterYear) return false;
    }
    if (selectedGroup !== 'all' && student.groupId !== selectedGroup) return false;
    return true;
  });

  // Filter groups based on user permissions
  const accessibleGroups = user?.role === 'admin' ? groups :
    groups.filter(group => user?.assignedGroups?.includes(group.id));

  // Filter groups by the selected year in the form (for add/edit dialog)
  const filteredGroupsForForm = accessibleGroups.filter(group => group.year === formData.year);

  // Filter groups for the filter dropdown - by selected year filter
  const filteredGroupsForFilter = selectedYear === 'all'
    ? accessibleGroups
    : accessibleGroups.filter(group => {
        // Handle both string and number types for robust comparison
        const groupYear = typeof group.year === 'string' ? Number(group.year) : group.year;
        const filterYear = typeof selectedYear === 'string' ? Number(selectedYear) : selectedYear;
        return groupYear === filterYear;
      });


  const getGroupName = (groupId: string) => {
    const group = groups.find(g => g.id === groupId);
    return group ? group.name : 'Unknown Group';
  };

  const getGroupCurrentUnit = (groupId: string) => {
    const group = groups.find(g => g.id === groupId);
    return group?.currentUnit || null;
  };

  const handleOpenDialog = (student?: Student) => {
    if (student) {
      setEditingStudent(student);
      setFormData({
        name: student.name,
        year: student.year,
        groupId: student.groupId,
      });
    } else {
      setEditingStudent(null);
      setFormData({
        name: '',
        year: 1,
        groupId: '',
      });
    }
    setError(null);
    setValidationErrors({});
    setOpenDialog(true);
  };

  const handleCloseDialog = () => {
    setOpenDialog(false);
    setEditingStudent(null);
    setError(null);
  };

  const validateStudentForm = (): boolean => {
    const errors: { [key: string]: string } = {};

    // Validate student name
    if (!formData.name.trim()) {
      errors.name = 'Student name is required';
    } else if (!validateName(formData.name.trim())) {
      errors.name = 'Student name must be 2-100 characters and contain only letters and spaces';
    }

    // Validate group selection
    if (!formData.groupId) {
      errors.groupId = 'Please select a group';
    }

    setValidationErrors(errors);
    return Object.keys(errors).length === 0;
  };

  const handleSave = async () => {
    if (!validateStudentForm()) {
      return;
    }

    try {
      const studentData = {
        name: sanitizeString(formData.name.trim()),
        studentId: editingStudent ? editingStudent.studentId : `ST${Date.now()}`, // Auto-generate for new students
        year: formData.year,
        groupId: formData.groupId,
      };

      if (editingStudent) {
        await updateStudent(editingStudent.id, studentData);
      } else {
        await addStudent(studentData);
      }

      handleCloseDialog();
    } catch (error) {
      setError('Failed to save student');
    }
  };

  const handleDelete = async (id: string) => {
    if (window.confirm('Are you sure you want to delete this student?')) {
      try {
        await deleteStudent(id);
      } catch (error) {
        setError('Failed to delete student');
      }
    }
  };

  const handleImportExcel = () => {
    setImportDialogOpen(true);
    setImportResults(null);
  };


  const handleDownloadTemplate = () => {
    try {
      downloadStudentTemplate();
    } catch (error) {
      setError('Failed to download template');
    }
  };

  const handleFileUpload = async (event: React.ChangeEvent<HTMLInputElement>) => {
    const file = event.target.files?.[0];
    if (!file) return;

    if (!file.name.endsWith('.xlsx') && !file.name.endsWith('.xls')) {
      setError('Please select an Excel file (.xlsx or .xls)');
      return;
    }

    setLoadingImport(true);
    setError(null);

    try {
      const { students: importedStudents, errors } = await importStudentsFromExcel(file);

      // Use the DatabaseContext addStudents method with Firebase sync
      const result = await addStudents(importedStudents);
      
      // Combine Excel parsing errors with duplicate detection errors
      const allErrors = [...errors, ...result.errors];
      
      setImportResults({ 
        success: result.added, 
        errors: allErrors 
      });
      
      // Debug: Log the results before refresh
      logger.log('Import completed:', {
        imported: importedStudents.length,
        added: result.added,
        skipped: result.skipped,
        errors: allErrors.length
      });

      // Check localStorage before refresh
      const studentsInStorageBefore = JSON.parse(localStorage.getItem('students') || '[]');
      logger.log('Students in localStorage before refresh:', studentsInStorageBefore.length);
      logger.log('Students in React state before refresh:', students.length);

      // Force refresh the students data to update the UI
      await forceRefresh();

      // Check localStorage and React state after refresh
      const studentsInStorageAfter = JSON.parse(localStorage.getItem('students') || '[]');
      logger.log('Students in localStorage after refresh:', studentsInStorageAfter.length);
      logger.log('Students in React state after refresh:', students.length);
      
      // Force a re-render by updating a dummy state
      setImportResults(prev => prev ? { ...prev, timestamp: Date.now() } : null);
      setRefreshTrigger(prev => prev + 1);
      
    } catch (error) {
      setError(`Import failed: ${error}`);
    } finally {
      setLoadingImport(false);
    }
  };

  const handleCloseImportDialog = () => {
    setImportDialogOpen(false);
    setImportResults(null);
  };

  // Group import handlers
  const handleOpenGroupImportDialog = () => {
    setGroupImportDialogOpen(true);
    setGroupImportPreview([]);
    setGroupImportWarnings([]);
    setGroupImportErrors([]);
  };

  const handleDownloadGroupTemplate = () => {
    generateStudentGroupImportTemplate(groups);
  };

  const handleGroupImportFileUpload = async (event: React.ChangeEvent<HTMLInputElement>) => {
    const file = event.target.files?.[0];
    if (!file) return;

    setLoadingGroupImport(true);
    setGroupImportPreview([]);
    setGroupImportWarnings([]);
    setGroupImportErrors([]);

    try {
      const { students: parsedStudents, errors, warnings } = await importStudentsByGroupsFromExcel(file);

      setGroupImportWarnings(warnings);
      setGroupImportErrors(errors);

      if (errors.length > 0) {
        setLoadingGroupImport(false);
        return;
      }

      // Generate next student IDs
      const existingStudents = await DatabaseService.getStudents();
      const existingStudentIds = existingStudents
        .map(s => {
          const idStr = s.studentId.replace('S', '');
          const id = parseInt(idStr);
          return isNaN(id) ? 0 : id;
        })
        .filter(id => id > 0); // Filter out invalid IDs
      let nextId = existingStudentIds.length > 0 ? Math.max(...existingStudentIds) + 1 : 1;

      // Create lookup maps for O(1) performance instead of O(n²)
      const existingStudentsByName = new Map(
        existingStudents.map(s => [s.name.toLowerCase(), s])
      );
      const groupsByName = new Map(
        groups.map(g => [g.name, g])
      );

      // Validate and prepare preview
      const preview = parsedStudents.map(student => {
        // Check if group exists
        const group = groupsByName.get(student.groupId);
        if (!group) {
          return {
            ...student,
            status: 'error' as const,
            message: `Group "${student.groupId}" not found`
          };
        }

        // Check if student with same name already exists
        const existingStudent = existingStudentsByName.get(student.name.toLowerCase());

        if (existingStudent) {
          return {
            ...student,
            status: 'exists' as const,
            message: `Already exists (${existingStudent.studentId})`,
            autoGeneratedId: existingStudent.studentId
          };
        }

        const autoGeneratedId = `S${String(nextId++).padStart(5, '0')}`;
        return {
          ...student,
          status: 'new' as const,
          message: 'Will be created',
          autoGeneratedId
        };
      });

      setGroupImportPreview(preview);
    } catch (error) {
      setGroupImportErrors([`Failed to parse file: ${error}`]);
    } finally {
      setLoadingGroupImport(false);
    }

    // Reset file input
    event.target.value = '';
  };

  const handleConfirmGroupImport = async () => {
    setLoadingGroupImport(true);

    try {
      const studentsToAdd = groupImportPreview
        .filter(s => s.status === 'new')
        .map(s => ({
          name: s.name,
          studentId: s.autoGeneratedId!,
          groupId: s.groupId,
          year: s.year,
          email: '',
          phone: ''
        }));

      if (studentsToAdd.length === 0) {
        setGroupImportErrors(['No new students to import']);
        setLoadingGroupImport(false);
        return;
      }

      const result = await addStudents(studentsToAdd);

      await forceRefresh();
      setRefreshTrigger(prev => prev + 1);

      setImportResults({
        success: result.added,
        errors: result.errors
      });

      setGroupImportDialogOpen(false);
      setGroupImportPreview([]);
      setImportDialogOpen(true); // Show results in the existing import dialog
    } catch (error) {
      setGroupImportErrors([`Import failed: ${error}`]);
    } finally {
      setLoadingGroupImport(false);
    }
  };

  const handleCloseGroupImportDialog = () => {
    setGroupImportDialogOpen(false);
    setGroupImportPreview([]);
    setGroupImportWarnings([]);
    setGroupImportErrors([]);
  };


  const columns: GridColDef[] = [
    { field: 'name', headerName: 'Name', width: 200 },
    { field: 'studentId', headerName: 'Student ID', width: 120 },
    { field: 'email', headerName: 'Email', width: 200 },
    { field: 'phone', headerName: 'Phone', width: 130 },
    { 
      field: 'year', 
      headerName: 'Year', 
      width: 80,
      renderCell: (params) => (
        <Chip label={`Year ${params.value}`} size="small" />
      ),
    },
    {
      field: 'unit',
      headerName: 'Current Unit',
      width: 120,
      renderCell: (params) => {
        const currentUnit = getGroupCurrentUnit(params.row.groupId);
        return (
          <Chip
            label={currentUnit || 'N/A'}
            size="small"
            color={currentUnit ? 'primary' : 'default'}
            variant={currentUnit ? 'filled' : 'outlined'}
          />
        );
      },
    },
    { 
      field: 'groupId', 
      headerName: 'Group', 
      width: 120,
      renderCell: (params) => getGroupName(params.value),
    },
    {
      field: 'actions',
      headerName: 'Actions',
      width: 120,
      sortable: false,
      filterable: false,
      renderCell: (params) => (
        <Box sx={{ display: 'flex', gap: 1 }}>
          <IconButton
            size="small"
            onClick={(e) => {
              e.stopPropagation();
              handleOpenDialog(params.row);
            }}
            color="primary"
          >
            <Edit fontSize="small" />
          </IconButton>
          <IconButton
            size="small"
            onClick={(e) => {
              e.stopPropagation();
              handleDelete(params.row.id);
            }}
            color="error"
          >
            <Delete fontSize="small" />
          </IconButton>
        </Box>
      ),
    },
  ];

  if (loading) {
    return (
      <Box sx={{ display: 'flex', justifyContent: 'center', alignItems: 'center', minHeight: 400 }}>
        <CircularProgress />
      </Box>
    );
  }

  return (
    <Box>
      <Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', mb: 3 }}>
        <Typography variant="h4">
          Students ({filteredStudents.length})
        </Typography>
        <Box>
          <Button
            variant="outlined"
            startIcon={<Upload />}
            onClick={handleImportExcel}
            sx={{ mr: 1 }}
          >
            Import Excel
          </Button>
          <Button
            variant="outlined"
            onClick={handleDownloadTemplate}
            sx={{ mr: 1 }}
          >
            Download Template
          </Button>
          {/* Admin-only: Import by Groups and Group Template */}
          {user?.role === 'admin' && (
            <>
              <Button
                variant="contained"
                color="secondary"
                startIcon={<Upload />}
                onClick={handleOpenGroupImportDialog}
                sx={{ mr: 1 }}
              >
                Import by Groups
              </Button>
              <Button
                variant="outlined"
                color="secondary"
                onClick={handleDownloadGroupTemplate}
                sx={{ mr: 1 }}
              >
                Group Template
              </Button>
            </>
          )}
          <Button
            variant="outlined"
            onClick={() => forceRefresh()}
            sx={{ mr: 1 }}
          >
            Refresh
          </Button>
          <Button
            variant="contained"
            startIcon={<Add />}
            onClick={() => handleOpenDialog()}
          >
            Add Student
          </Button>
        </Box>
      </Box>

      {/* Filters */}
      <Card sx={{ mb: 3 }}>
        <CardContent>
          <Grid container spacing={2} alignItems="center">
            <Grid item xs={12} sm={4}>
              <FormControl fullWidth>
                <InputLabel>Filter by Year</InputLabel>
                <Select
                  value={selectedYear}
                  label="Filter by Year"
                  onChange={(e) => setSelectedYear(e.target.value as number | 'all')}
                >
                  <MenuItem value="all">All Years</MenuItem>
                  {[1, 2, 3, 4, 5, 6].map(year => (
                    <MenuItem key={year} value={year}>Year {year}</MenuItem>
                  ))}
                </Select>
              </FormControl>
            </Grid>
            <Grid item xs={12} sm={4}>
              <FormControl fullWidth>
                <InputLabel>Filter by Group</InputLabel>
                <Select
                  value={selectedGroup}
                  label="Filter by Group"
                  onChange={(e) => setSelectedGroup(e.target.value)}
                >
                  <MenuItem value="all">All Groups</MenuItem>
                  {filteredGroupsForFilter.map(group => (
                    <MenuItem key={group.id} value={group.id}>{group.name}</MenuItem>
                  ))}
                </Select>
              </FormControl>
            </Grid>
          </Grid>
        </CardContent>
      </Card>

      {/* Students Table */}
      <Card>
        <CardContent>
          <Typography variant="subtitle2" color="text.secondary" gutterBottom>
            Showing {filteredStudents.length} student{filteredStudents.length !== 1 ? 's' : ''}
          </Typography>
        </CardContent>
        <Box sx={{ height: 600, width: '100%' }}>
          <DataGrid
            rows={filteredStudents.map(student => ({
              ...student,
              id: student.id || `student-${Date.now()}-${Math.random()}`
            }))}
            columns={columns}
            pageSize={50}
            rowsPerPageOptions={[25, 50, 100]}
            disableSelectionOnClick
            getRowId={(row) => row.id}
            onRowClick={(params) => {
              setSelectedStudent(params.row);
            }}
            sx={{
              '& .MuiDataGrid-row:hover': {
                backgroundColor: 'rgba(33, 150, 243, 0.04)',
              },
              '& .MuiDataGrid-row.Mui-selected': {
                backgroundColor: 'rgba(33, 150, 243, 0.12)',
              },
            }}
          />
        </Box>
      </Card>

      {/* Action Buttons for Selected Student */}
      <Card sx={{ mt: 2 }}>
        <CardContent>
          <Typography variant="h6" gutterBottom>
            Quick Actions
          </Typography>
          {selectedStudent ? (
            <>
              <Typography variant="body2" color="text.secondary" sx={{ mb: 2 }}>
                Selected: <strong>{selectedStudent.name}</strong> (ID: {selectedStudent.studentId})
              </Typography>
              <Box sx={{ display: 'flex', gap: 2 }}>
                <Button
                  variant="outlined"
                  startIcon={<Edit />}
                  onClick={() => handleOpenDialog(selectedStudent)}
                >
                  Edit Student
                </Button>
                <Button
                  variant="outlined"
                  color="error"
                  startIcon={<Delete />}
                  onClick={() => handleDelete(selectedStudent.id)}
                >
                  Delete Student
                </Button>
              </Box>
            </>
          ) : (
            <>
              <Typography variant="body2" color="text.secondary" sx={{ mb: 2 }}>
                Click on a student row above or use the action buttons in the table to select a student
              </Typography>
              <Box sx={{ display: 'flex', gap: 2 }}>
                <Button
                  variant="outlined"
                  startIcon={<Edit />}
                  disabled
                >
                  Edit Student
                </Button>
                <Button
                  variant="outlined"
                  color="error"
                  startIcon={<Delete />}
                  disabled
                >
                  Delete Student
                </Button>
              </Box>
            </>
          )}
        </CardContent>
      </Card>

      {/* Add/Edit Student Dialog */}
      <Dialog open={openDialog} onClose={handleCloseDialog} maxWidth="sm" fullWidth>
        <DialogTitle>
          {editingStudent ? 'Edit Student' : 'Add New Student'}
        </DialogTitle>
        <DialogContent>
          {error && <Alert severity="error" sx={{ mb: 2 }}>{error}</Alert>}

          <Grid container spacing={2} sx={{ mt: 1 }}>
            <Grid item xs={12}>
              <TextField
                fullWidth
                label="Student Name *"
                value={formData.name}
                onChange={(e) => {
                  setFormData({ ...formData, name: e.target.value });
                  if (validationErrors.name) {
                    setValidationErrors({ ...validationErrors, name: '' });
                  }
                }}
                error={!!validationErrors.name}
                helperText={validationErrors.name || 'Full name of the student'}
              />
            </Grid>
            <Grid item xs={12} sm={6}>
              <FormControl fullWidth>
                <InputLabel>Year *</InputLabel>
                <Select
                  value={formData.year}
                  label="Year *"
                  onChange={(e) => setFormData({ ...formData, year: e.target.value as number, groupId: '' })}
                >
                  {[1, 2, 3, 4, 5, 6].map(year => (
                    <MenuItem key={year} value={year}>Year {year}</MenuItem>
                  ))}
                </Select>
              </FormControl>
            </Grid>
            <Grid item xs={12} sm={6}>
              <FormControl fullWidth error={!!validationErrors.groupId}>
                <InputLabel>Group *</InputLabel>
                <Select
                  value={formData.groupId}
                  label="Group *"
                  onChange={(e) => {
                    setFormData({ ...formData, groupId: e.target.value });
                    if (validationErrors.groupId) {
                      setValidationErrors({ ...validationErrors, groupId: '' });
                    }
                  }}
                >
                  {filteredGroupsForForm.map(group => (
                    <MenuItem key={group.id} value={group.id}>
                      {group.name}
                    </MenuItem>
                  ))}
                  {filteredGroupsForForm.length === 0 && (
                    <MenuItem disabled>No groups available for this year</MenuItem>
                  )}
                </Select>
                {validationErrors.groupId && (
                  <Typography variant="caption" color="error" sx={{ mt: 0.5 }}>
                    {validationErrors.groupId}
                  </Typography>
                )}
              </FormControl>
            </Grid>
            {!editingStudent && (
              <Grid item xs={12}>
                <Alert severity="info">
                  Student ID will be auto-generated. Units are assigned when recording attendance/assessments.
                </Alert>
              </Grid>
            )}
          </Grid>
        </DialogContent>
        <DialogActions>
          <Button onClick={handleCloseDialog}>Cancel</Button>
          <Button onClick={handleSave} variant="contained">
            {editingStudent ? 'Update' : 'Add'} Student
          </Button>
        </DialogActions>
      </Dialog>

      {/* Import Excel Dialog */}
      <Dialog open={importDialogOpen} onClose={handleCloseImportDialog} maxWidth="md" fullWidth>
        <DialogTitle>
          Import Students from Excel
        </DialogTitle>
        <DialogContent>
          {error && <Alert severity="error" sx={{ mb: 2 }}>{error}</Alert>}
          
          {!importResults ? (
            <Box>
              <Typography variant="body1" sx={{ mb: 2 }}>
                Upload an Excel file to import students. Make sure your file follows the required format.
              </Typography>
              
              <Box sx={{ mb: 2 }}>
                <Button
                  variant="outlined"
                  onClick={handleDownloadTemplate}
                  sx={{ mr: 2 }}
                >
                  Download Template
                </Button>
                <Typography variant="caption" color="text.secondary">
                  Download the template to see the required format
                </Typography>
              </Box>

              <Box sx={{ border: '2px dashed #ccc', p: 3, textAlign: 'center', borderRadius: 1 }}>
                <input
                  type="file"
                  accept=".xlsx,.xls"
                  onChange={handleFileUpload}
                  style={{ display: 'none' }}
                  id="excel-upload"
                />
                <label htmlFor="excel-upload">
                  <Button
                    variant="contained"
                    component="span"
                    startIcon={<Upload />}
                    disabled={loadingImport}
                  >
                    {loadingImport ? 'Processing...' : 'Choose Excel File'}
                  </Button>
                </label>
                <Typography variant="body2" color="text.secondary" sx={{ mt: 1 }}>
                  Supported formats: .xlsx, .xls
                </Typography>
              </Box>

              <Alert severity="info" sx={{ mt: 2 }}>
                <Typography variant="body2">
                  <strong>Required columns:</strong> Student Name (or Name), Year, Group (or Group ID)<br/>
                  <strong>Optional columns:</strong> Student ID, Email, Phone, Unit<br/>
                  <strong>Column name variations supported:</strong><br/>
                  • Name: "name", "Student Name", "Name"<br/>
                  • Year: "year", "Year", "Academic Year"<br/>
                  • Group: "group", "Group", "Group ID", "Group Name"<br/>
                  <strong>Year:</strong> Must be a number between 1 and 6<br/>
                  <strong>Group:</strong> Can be group ID (e.g., group-31) or group name (e.g., "Morning Class"). Automatically matched from Firebase groups.<br/>
                  <strong>Student ID:</strong> Auto-generated if not provided
                </Typography>
              </Alert>
            </Box>
          ) : (
            <Box>
              <Typography variant="h6" gutterBottom>
                Import Results
              </Typography>
              
              <Alert 
                severity={importResults.errors.length > 0 ? "warning" : "success"} 
                sx={{ mb: 2 }}
              >
                Successfully imported {importResults.success} students
                {importResults.errors.length > 0 && ` with ${importResults.errors.length} errors`}
              </Alert>

              {importResults.errors.length > 0 && (
                <Box>
                  <Typography variant="subtitle1" gutterBottom>
                    Errors:
                  </Typography>
                  <Box sx={{ maxHeight: 200, overflow: 'auto', border: '1px solid #ccc', p: 1, borderRadius: 1 }}>
                    {importResults.errors.map((error, index) => (
                      <Typography key={index} variant="body2" color="error" sx={{ mb: 0.5 }}>
                        • {error}
                      </Typography>
                    ))}
                  </Box>
                </Box>
              )}
            </Box>
          )}
        </DialogContent>
        <DialogActions>
          <Button onClick={handleCloseImportDialog}>
            {importResults ? 'Close' : 'Cancel'}
          </Button>
          {importResults && (
            <Button onClick={handleCloseImportDialog} variant="contained">
              Done
            </Button>
          )}
        </DialogActions>
      </Dialog>

      {/* Group Import Dialog */}
      <Dialog open={groupImportDialogOpen} onClose={handleCloseGroupImportDialog} maxWidth="lg" fullWidth>
        <DialogTitle>
          Import Students by Groups
        </DialogTitle>
        <DialogContent>
          {groupImportErrors.length > 0 && (
            <Alert severity="error" sx={{ mb: 2 }}>
              <Typography variant="subtitle2" gutterBottom>Errors:</Typography>
              {groupImportErrors.map((error, index) => (
                <Typography key={index} variant="body2">• {error}</Typography>
              ))}
            </Alert>
          )}

          {groupImportWarnings.length > 0 && (
            <Alert severity="warning" sx={{ mb: 2 }}>
              <Typography variant="subtitle2" gutterBottom>Warnings:</Typography>
              {groupImportWarnings.map((warning, index) => (
                <Typography key={index} variant="body2">• {warning}</Typography>
              ))}
            </Alert>
          )}

          {groupImportPreview.length === 0 ? (
            <Box>
              <Typography variant="body1" sx={{ mb: 2 }}>
                Upload an Excel file with students organized by groups. Each column should represent a group.
              </Typography>

              <Box sx={{ mb: 2 }}>
                <Button
                  variant="outlined"
                  color="secondary"
                  onClick={handleDownloadGroupTemplate}
                  sx={{ mr: 2 }}
                >
                  Download Template
                </Button>
                <Typography variant="caption" color="text.secondary">
                  Download the template with your current groups pre-filled
                </Typography>
              </Box>

              <Box sx={{ border: '2px dashed #ccc', p: 3, textAlign: 'center', borderRadius: 1 }}>
                <input
                  type="file"
                  accept=".xlsx,.xls"
                  onChange={handleGroupImportFileUpload}
                  style={{ display: 'none' }}
                  id="group-excel-upload"
                />
                <label htmlFor="group-excel-upload">
                  <Button
                    variant="contained"
                    color="secondary"
                    component="span"
                    startIcon={<Upload />}
                    disabled={loadingGroupImport}
                  >
                    {loadingGroupImport ? 'Processing...' : 'Choose Excel File'}
                  </Button>
                </label>
                <Typography variant="body2" color="text.secondary" sx={{ mt: 1 }}>
                  Supported formats: .xlsx, .xls
                </Typography>
              </Box>

              <Alert severity="info" sx={{ mt: 2 }}>
                <Typography variant="body2">
                  <strong>Excel Format:</strong><br/>
                  • First row: Group IDs (e.g., GroupA1-Y3, GroupA2-Y3)<br/>
                  • Below each group: Student names (one per cell)<br/>
                  • Empty cells are automatically skipped<br/>
                  • Student IDs will be auto-generated (S00001, S00002, etc.)<br/>
                  • Year is extracted from group ID (e.g., GroupA1-Y<strong>3</strong> = Year 3)
                </Typography>
              </Alert>
            </Box>
          ) : (
            <Box>
              <Typography variant="h6" gutterBottom>
                Import Preview ({groupImportPreview.length} students)
              </Typography>

              <Box sx={{ mb: 2 }}>
                <Chip
                  label={`${groupImportPreview.filter(s => s.status === 'new').length} New`}
                  color="success"
                  size="small"
                  sx={{ mr: 1 }}
                />
                <Chip
                  label={`${groupImportPreview.filter(s => s.status === 'exists').length} Existing`}
                  color="warning"
                  size="small"
                  sx={{ mr: 1 }}
                />
                <Chip
                  label={`${groupImportPreview.filter(s => s.status === 'error').length} Errors`}
                  color="error"
                  size="small"
                />
              </Box>

              <TableContainer component={Paper} sx={{ maxHeight: 400 }}>
                <Table stickyHeader size="small">
                  <TableHead>
                    <TableRow>
                      <TableCell>Status</TableCell>
                      <TableCell>Student Name</TableCell>
                      <TableCell>Group</TableCell>
                      <TableCell>Year</TableCell>
                      <TableCell>Student ID</TableCell>
                      <TableCell>Message</TableCell>
                    </TableRow>
                  </TableHead>
                  <TableBody>
                    {groupImportPreview.map((student, index) => (
                      <TableRow
                        key={index}
                        sx={{
                          backgroundColor:
                            student.status === 'new' ? '#e8f5e9' :
                            student.status === 'exists' ? '#fff3e0' :
                            '#ffebee'
                        }}
                      >
                        <TableCell>
                          <Chip
                            label={student.status}
                            size="small"
                            color={
                              student.status === 'new' ? 'success' :
                              student.status === 'exists' ? 'warning' :
                              'error'
                            }
                          />
                        </TableCell>
                        <TableCell>{student.name}</TableCell>
                        <TableCell>{student.groupId}</TableCell>
                        <TableCell>
                          <Chip label={`Year ${student.year}`} size="small" />
                        </TableCell>
                        <TableCell>
                          <Typography
                            variant="body2"
                            sx={{
                              fontFamily: 'monospace',
                              fontWeight: student.status === 'new' ? 'bold' : 'normal'
                            }}
                          >
                            {student.autoGeneratedId || '-'}
                          </Typography>
                        </TableCell>
                        <TableCell>
                          <Typography variant="caption" color="text.secondary">
                            {student.message}
                          </Typography>
                        </TableCell>
                      </TableRow>
                    ))}
                  </TableBody>
                </Table>
              </TableContainer>

              <Alert severity="info" sx={{ mt: 2 }}>
                Only <strong>{groupImportPreview.filter(s => s.status === 'new').length} new students</strong> will be imported.
                Existing students and errors will be skipped.
              </Alert>
            </Box>
          )}
        </DialogContent>
        <DialogActions>
          <Button onClick={handleCloseGroupImportDialog}>Cancel</Button>
          {groupImportPreview.length > 0 && groupImportPreview.some(s => s.status === 'new') && (
            <Button
              onClick={handleConfirmGroupImport}
              variant="contained"
              color="secondary"
              disabled={loadingGroupImport}
            >
              {loadingGroupImport ? 'Importing...' : `Import ${groupImportPreview.filter(s => s.status === 'new').length} Students`}
            </Button>
          )}
        </DialogActions>
      </Dialog>

    </Box>
  );
};

export default Students;
